# Implement a SHA-1 keyed MAC

Code description:

1. The function `sha1(message: &[u8]) -> Result<[u8; 20], Error>` implements the SHA-1 algorithm. It receives an input message `message` as an array of bytes and returns the result of the calculation or an error `Error`. First, an empty vector `padded_message` is created, which is expanded using `extend_from_slice(message)` by adding the message `message` to the vector. After that, the byte `0x80` is added to `padded_message`, which indicates the end of the message. Next, zero bytes are added to `padded_message` until its length is a multiple of 64 (448 % 512) bytes. The variable `message_length_bits` contains the length of the message `message` in bits. After that, the message length is added to `padded_message` as a 64-bit number in big-endian order. The variables `h0`, `h1`, `h2`, `h3`, `h4` are initialized with the initial values of the hash. Next, the iteration begins on blocks `chunk` of size 64 bytes. In each iteration, the chunk is divided into 16 32-bit words. Next, the 16 words are expanded to 80 words using a recursive formula. The variables `a`, `b`, `c`, `d`, `e` are initialized with the values `h0`, `h1`, `h2`, `h3`, `h4`. Each word `word` from the list `words` is processed in accordance with the constants and logic defined for each round. The values `a`, `b`, `c`, `d`, `e` and hash codes are updated at each iteration. At the end of each block, the updated values `a`, `b`, `c`, `d`, `e` are added to the corresponding hash codes `h0`, `h1`, `h2`, `h3`, `h4`. After iterating over all blocks, the result of SHA-1 encryption is formed in the form of an array `result` of 20 bytes in length.

2. The `calculate_mac(key: &[u8], message: &[u8]) -> Result<[u8; 20], Error>` function implements the calculation of the MAC using the SHA-1 algorithm. It receives the key `key` and the message `message` as arrays of bytes and returns the result of the calculation or an error `Error`.

3. The `main()` function contains an example of using the MAC calculation. It initializes the `key` and `message` variables, calls the `calculate_mac()` function to calculate the MAC and compares the results.

So the program uses its own SHA-1 implementation and does not rely on built-in libraries or external tools to calculate the SHA-1 hash function. Next, a similar operation to SHA1(key || message) is performed, where "||" denotes the concatenation of byte sequences. The result is the MAC code of the message using the key and the SHA-1 hash function. And finally, after calculating the MAC for the original message, checks are performed: message forgery and creation of a new MAC without knowing the key. The results demonstrate that the forged message has a different MAC from the original message, and the new MAC cannot be created without knowing the secret key.
